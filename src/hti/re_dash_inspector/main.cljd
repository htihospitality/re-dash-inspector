(ns hti.re-dash-inspector.main
  (:require ["package:flutter/material.dart" :as m]
            ["package:devtools_extensions/devtools_extensions.dart" :as ext]
            ["package:devtools_app_shared/service.dart" :as service]
            ["package:devtools_app_shared/ui.dart" :as ui]
            ["package:devtools_app_shared/utils.dart" :as utils]
            ["package:vm_service/vm_service.dart" :as vm-service]
            ["dart:async" :as async]
            [cljd.flutter :as f]
            [cljd.reader :as r]
            [clojure.string :as string]))

(deftype Inspector
    [state]

  (getState [_]
    state))

(deftype Debouncer
    [^:mutable ^async/Timer? timer]

  (debounce [_ duration f]
    (when timer (.cancel timer))
    (set! timer (async/Timer duration f))
    nil)

  (dispose [_]
    (when timer (.cancel timer))))

(defn ^Debouncer ->debouncer
  []
  (->Debouncer nil))

(defn ->state
  []
  (-> ^Inspector (get utils/globals Inspector) .getState))

(defn- defer
  "Defers execution of the given function `f` until the next event loop."
  [f]
  (async/Timer.run f))

(defn- search-filter
  "Searches all keys and values containing the search text."
  [item search-text]
  (if search-text
    (-> (pr-str item)
        string/lower-case
        (string/includes? search-text))
    true))

(defn- map-row
  [[k v] state]
  (m/Row
    .crossAxisAlignment m/CrossAxisAlignment.center
    .children
    [(f/widget
       (m/Flexible .fit m/FlexFit.tight)
       (m/Text (or (pr-str k) "")))
     (m/SizedBox .width 10)
     (f/widget
       (m/Expanded .flex 2)
       (m/InkWell
         .onTap (fn []
                  (when (and (coll? v) (not (coll? k)))
                    (swap! state (fn [s]
                                   (-> (update s :selected-path #(-> % vec (conj k)))
                                       (assoc :search-text ""))))))
         .mouseCursor (if (coll? v)
                        m/WidgetStateMouseCursor.clickable
                        m/SystemMouseCursors.basic))
       (m/Text (or (pr-str v) "")
               .maxLines 100
               .overflow m/TextOverflow.ellipsis))]))

(defn- seq-row
  [item idx state]
  (m/Row
    .crossAxisAlignment m/CrossAxisAlignment.center
    .children
    [(f/widget
       (m/Expanded .flex 2)
       (m/InkWell
         .onTap (fn []
                  (when (coll? item)
                    (swap! state (fn [s]
                                   (-> (update s :selected-path #(-> % vec (conj idx)))
                                       (assoc :search-text ""))))))
         .mouseCursor (if (coll? item)
                        m/WidgetStateMouseCursor.clickable
                        m/SystemMouseCursors.basic))
       (m/Text (or (pr-str item) "")
               .maxLines 10
               .overflow m/TextOverflow.ellipsis))]))

(def data-table
  "The data for the selected search / filter"
  (f/widget

    :watch [{:keys [db selected-path search-text]}
            (->state) :as state

            dark-mode? (some-> ^ext/ExtensionManager
                               (get utils/globals ext/ExtensionManager)
                               .-darkThemeEnabled)

            color-scheme (atom (if dark-mode?
                                 ui/darkColorScheme
                                 ui/lightColorScheme))

            ;; Narrow down the db map to only what's been selected
            ;; (eg. when the user selected a nested map value from the ui)
            db' (atom (if (seq selected-path)
                        (get-in db selected-path)
                        db))

            ;; The filtered & sorted list of map entries
            ;; to display on the ui
            items (cond

                    (map? db')
                    (->> db'
                         (into [])
                         (filter #(search-filter % search-text))
                         (sort-by (fn [[k _]] k))
                         atom)

                    (or (sequential? db') (set? db'))
                    (->> db'
                         (filter #(search-filter % search-text))
                         atom))

            items-count (atom (count items))]

    m/Expanded
    (m/Column
      .children
      [(f/widget
         m/Expanded
         (m/ListView.builder
           .itemCount items-count
           .itemBuilder
           (f/build
             [idx]
             (f/widget
               (m/Container
                 .color (ui/alternatingColorForIndex idx color-scheme)
                 .padding (m/EdgeInsets.symmetric .vertical 3))
               (let [item (get items idx)]
                 (if (map? db')
                   (map-row item state)
                   (seq-row item idx state)))))))
       (m/SizedBox .height 3)
       (f/widget
         ui/OutlineDecoration.onlyTop
         (m/Row
           .children
           [(m/Text (str "Count: " items-count))]))])))


(def breadcrumbs
  "When selecting an item from the table,
  breadcrumbs will show the way back."
  (f/widget

    :watch [{:keys [selected-path]}
            (->state) :as state]

    :when (seq selected-path)

    (m/Align
      .alignment m/Alignment.centerLeft)
    (m/Column
      .children
      [(f/widget
         (m/Wrap
           .children
           (concat
             [(f/widget
                (m/InkWell
                  .onTap (fn []
                           (swap! state assoc :selected-path [])))
                (m/Text "x"))]
             (map-indexed
               (fn [idx crumb]
                 (f/widget
                   (m/InkWell
                     .onTap (fn []
                              (swap! state (fn [s]
                                             (-> (update s :selected-path #(-> (inc idx) (take %) vec))
                                                 (assoc :search-text ""))))))
                   (m/Container
                     .constraints (m/BoxConstraints .maxWidth 1000))
                   (m/Text (str " / " (pr-str crumb))
                           .overflow m/TextOverflow.ellipsis)))
               selected-path))))
       (m/SizedBox .height 10)])))


(def search
  (f/widget

    :get {^m/TextEditingController search-controller :search-controller}

    :managed [debouncer (->debouncer)]

    :watch [{:keys [search-text]
             :or   {search-text ""}}
            (->state)

            _ (do (when (string/blank? search-text)
                    (.-text! search-controller "")) nil)
            :refresh-on search-text]

    (ui/DevToolsClearableTextField
      .labelText "Search"
      .prefixIcon (m/Icon (m/Icons.search))
      .onChanged (fn [s]
                   (.debounce debouncer
                              (Duration .milliseconds 250)
                              #(swap! (->state) assoc :search-text s)))
      .controller search-controller)))


(def header
  (ui/AreaPaneHeader
    .title (m/Text "re-dash Inspector")))

(def footer
  (f/widget
    :context ctx
    ui/RoundedOutlinedBorder
    (m/Padding .padding (m/EdgeInsets.all 2))
    (m/Row
      .mainAxisAlignment m/MainAxisAlignment.center
      .children
      [(m/Text "Find re-dash useful? Consider supporting us via ")
       (m/Text.rich
         (ui/LinkTextSpan
           .link (ui/Link
                   .display "Github Sponsors"
                   .url "https://github.com/sponsors/htihospitality")
           .context ctx))])))


(defn re-dash-event?
  [{:flds [extensionKind] :as ^vm-service/Event _}]
  (if (#{"re-dash"} extensionKind)
    true false))


(defn handler
  [{:flds [extensionData] :as ^vm-service/Event _}]
  (when-let [db (some-> ^vm-service/ExtensionData extensionData
                        .-data
                        (get "db"))]
    (defer #(swap! (->state) assoc :db (r/read-string db)))))


(defn view
  [^utils/AutoDisposeMixin parent]
  (f/widget

    :managed [search-controller (m/TextEditingController)]

    :let [service-manager
          ^service/ServiceManager
          (get utils/globals service/ServiceManager)]

    :bind {:search-controller search-controller}

    :watch [;; Wait for the vm service to be available
            ^vm-service/VmService? vm-service
            (-> service-manager .-onServiceAvailable await)

            ;; Subscribe to post events from re-dash.
            ;; The reason we keep reference to and auto
            ;; dispose of the StreamSubscription as opposed to
            ;; merely :watch on the stream, is because this way
            ;; the subscription doesn't pause when the devtools window is
            ;; out of focus, which would otherwise cause us to lose events
            ;; sent from the app.
            _ (when vm-service
                (.cancelStreamSubscriptions parent)
                (.autoDisposeStreamSubscription
                  parent
                  (-> vm-service
                      .-onExtensionEvent
                      (.where #(re-dash-event? %))
                      (.listen handler)))
                nil)

            ;; Wait for the connected app's main isolate
            {:flds [id] :as ^vm-service/IsolateRef? _}
            (when vm-service
              (-> service-manager .-isolateManager .-mainIsolate))

            ;; Set the pause mode in the debugger to none to try and guard
            ;; against pausing when doing a hot restart of the app
            ;; TODO
            ;; This does not really seem to help in preventing a pause
            ;; when doing a hot restart of the app, so this can possibly
            ;; be removed at some stage.
            _ (when id
                (.setIsolatePauseMode
                  vm-service id
                  .exceptionPauseMode "None"
                  .shouldPauseOnExit false))

            ;; Listen for isolate pause events
            {:flds [kind] :as ^vm-service/Event? _}
            (when id (.getIsolatePauseEvent vm-service id))

            ;; When we detect a pause event, we un-pause to try and guard
            ;; against inadvertent pausing when doing a hot restart of the app.
            ;; TODO
            ;; This does mean we cannot pause the app in the debugger at all
            ;; so ideally we need to determine why a hot restart pauses the isolate?
            ;; Additionally, due to the undesirable pause when the app restarts,
            ;; there lingers a weird paused notification in the devtools window that
            ;; does not seem to affect anything, but it does not automatically
            ;; disappear either - a refresh of devtools does get rid of it though.
            _ (when (= "PauseStart" kind)
                (.resume vm-service id))]


    (m/Column
      .children
      [header
       (m/SizedBox .height 10)
       search
       (m/SizedBox .height 10)
       breadcrumbs
       data-table
       (m/SizedBox .height 10)
       footer])))


(defn main
  []

  (m/WidgetsFlutterBinding.ensureInitialized)

  ;; Initialise app state atom and store in provided globals
  (utils/setGlobal Inspector (Inspector. (atom {})))

  (f/run

    ext/DevToolsExtension

    ;; We reify StatefulWidget so we can use
    ;; AutoDisposeMixin to auto dispose
    ;; our event stream subscription.

    (reify :extends m/StatefulWidget
      :no-meta true
      (createState [_]
        (reify :extends m/State
          :no-meta true

          (build [this _ctx]
            (view this))

          ^:mixin utils/AutoDisposeMixin
          (autoDisposeStreamSubscription [_this _sub]))))))
